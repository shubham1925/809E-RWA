#!/usr/bin/env python

import rospy
import math
import sys
import tf
import numpy as np
from geometry_msgs.msg import Twist, Point
from sensor_msgs.msg import LaserScan
from tf.transformations import euler_from_quaternion
from velocity_publisher import computation

# Initialize your ROS node
rospy.init_node("move_robot", anonymous=True, disable_signals=True)
# Set up a publisher to the /cmd_vel topic
pub = rospy.Publisher("cmd_vel", Twist, queue_size=5)
# Declare a message of type Twist
velocity_msg = Twist()
# publish the velocity at 4 Hz (4 times per second)
rate = rospy.Rate(4)
# set up a tf listener to retrieve transform between the robot and the world
tf_listener = tf.TransformListener()
# parent frame for the listener
parent_frame = 'odom'
# child frame for the listener
child_frame = 'base_footprint'
# gains for the proportional controllers. These values can be tuned.
k_h_gain = 0.5
k_v_gain = 1

distance_to_goal = 0
relative_dir = 0
# 1-clockwise, 0-anticlockwise
rotation_dir = 0

# List of all the start positions
positions = [[-2.0, 0.0], [-1.0, 2.0], [1.0, 2.0], [2.0, 0.0], [1.0, -2.0], [-1.0, -2.0]]

goal = 0
current_position = rospy.get_param('current_position', 0)

multiplier = 1

flag = 0
first_x = 0.0
first_y = 0.0

try:
    tf_listener.waitForTransform(parent_frame, child_frame, rospy.Time(), rospy.Duration(1.0))
except (tf.Exception, tf.ConnectivityException, tf.LookupException):
    rospy.loginfo("Cannot find transform between {p} and {c}".format(p=parent_frame, c=child_frame))
    rospy.signal_shutdown("tf Exception")


def go_straight():
    """Move the robot in a straight line until it has driven a certain distance.

    The linear velocity is modified for a Twist message and then published on /cmd_vel.

    """

    # get distance and linear velocity from command line
    distance_to_drive, linear_velocity = get_distance_velocity()
    global velocity_msg
    # update linear.x from the command line
    velocity_msg.linear.x = linear_velocity
    # get the current time (s)
    t_0 = rospy.Time.now().to_sec()
    # keep track of the distance
    distance_moved = 0.0

    # while the amount of distance has not been reached
    while distance_moved <= distance_to_drive:
        rospy.loginfo("TurtleBot is moving")
        pub.publish(velocity_msg)
        rate.sleep()
        # time in sec in the loop
        t_1 = rospy.Time.now().to_sec()
        distance_moved = (t_1 - t_0) * abs(linear_velocity)
        rospy.loginfo("distance moved: {d}".format(d=distance_moved))

    rospy.logwarn("Distance reached")
    # finally, stop the robot when the distance is moved
    velocity_msg.linear.x = 0.0
    pub.publish(velocity_msg)


def rotate():
    """Make the robot rotate in place

    The angular velocity is modified before publishing the message on the topic /cmd_vel.
    """

    # angular_velocity = math.radians(angular_velocity)
    relative_angle_degree, angular_velocity = get_rotation()
    velocity_msg.angular.z = angular_velocity

    t0 = rospy.Time.now().to_sec()
    while True:
        rospy.loginfo("TurtleBot is rotating")
        pub.publish(velocity_msg)
        rate.sleep()
        t1 = rospy.Time.now().to_sec()
        rospy.loginfo("t0: {t}".format(t=t0))
        rospy.loginfo("t1: {t}".format(t=t1))
        current_angle_degree = (t1 - t0) * angular_velocity

        rospy.loginfo("current angle: {a}".format(a=current_angle_degree))
        rospy.loginfo("angle to reach: {a}".format(a=relative_angle_degree))
        if abs(current_angle_degree) >= math.radians(abs(relative_angle_degree)):
            rospy.loginfo("reached")
            break
    # finally, stop the robot when the distance is moved
    velocity_msg.angular.z = 0
    pub.publish(velocity_msg)


def get_odom_data():
    """Get the current pose of the robot from the /odom topic

    Return
    ----------
    The position (x, y, z) and the yaw of the robot.

    """
    try:
        (trans, rot) = tf_listener.lookupTransform(parent_frame, child_frame, rospy.Time(0))
        # rotation is a list [r, p, y]
        rotation = euler_from_quaternion(rot)
    except (tf.Exception, tf.ConnectivityException, tf.LookupException):
        rospy.loginfo("TF Exception")
        return
    # return the position (x, y, z) and the yaw
    return Point(*trans), rotation[2]


# Store the initial position of the robot, which is required further
first, _ = get_odom_data()
first_x = first.x
first_y = first.y


def get_goal():
    """Get goal arguments from the command line

    The first argument is the x coordinate.
    The second argument is the y coordinate.

    Return
    ----------
    The goal (x, y) to reach.
    """

    global goal
    if len(sys.argv) == 2:
        goal = float(sys.argv[1])
    else:
        sys.exit('Not enough arguments')

    if positions[int(goal)] != positions[int(current_position)]:
        return positions[int(goal)][0], positions[int(goal)][1]
    rospy.loginfo("Goal Already Reached")
    rospy.signal_shutdown("Goal Already Reached")


def go_to_goal():
    """Task the robot to reach a goal (x,y) using a proportional controller.

    The current pose of the robot is retrieved from /odom topic.
    Publish the message to /cmd_vel topic.


    """

    # get current pose of the robot from the /odom topic
    (position, rotation) = get_odom_data()
    last_rotation = 0
    # get the goal to reach from arguments passed to the command line
    goal_x, goal_y = get_goal()
    # compute the distance from the current position to the goal
    global distance_to_goal
    distance_to_goal = computation.compute_distance(position.x, position.y, goal_x, goal_y)
    global relative_dir
    relative_dir = ((0 - position.x) * (goal_y - position.y) - (0 - position.y) * (goal_x - position.x))

    if distance_to_goal > 0.05:
        (position, rotation) = get_odom_data()
        x_start = position.x
        y_start = position.y
        rospy.loginfo("x = {0}, y = {1}".format(x_start, y_start))
        angle_to_goal = math.atan2(goal_y - y_start, goal_x - x_start)

        # the domain of arc tan(x) is (-inf, inf)
        # we would like to restrict the domain to (0, 2pi)
        if angle_to_goal < -math.pi / 4 or angle_to_goal > math.pi / 4:
            if 0 > goal_y > y_start:
                angle_to_goal = -2 * math.pi + angle_to_goal
            elif 0 <= goal_y < y_start:
                angle_to_goal = 2 * math.pi + angle_to_goal
        if last_rotation > math.pi - 0.1 and rotation <= 0:
            rotation = 2 * math.pi + rotation
        elif last_rotation < -math.pi + 0.1 and rotation > 0:
            rotation = -2 * math.pi + rotation

        # proportional control for rotating the robot
        velocity_msg.angular.z = k_v_gain * angle_to_goal - rotation
        distance_to_goal = computation.compute_distance(position.x, position.y, goal_x, goal_y)
        # proportional control to move the robot forward
        # We will drive the robot at a maximum speed of 0.5
        velocity_msg.linear.x = min(k_h_gain * distance_to_goal, 0.1)

        # set the z angular velocity for positive and negative rotations
        global rotation_dir
        if velocity_msg.angular.z > 0:
            velocity_msg.angular.z = min(velocity_msg.angular.z, 0.5)
            rotation_dir = 0
        else:
            velocity_msg.angular.z = max(velocity_msg.angular.z, -0.5)
            rotation_dir = 1

        # update the new rotation for the next loop
        pub.publish(velocity_msg)
        rate.sleep()

    # Rotate the robot to face the center
    velocity_msg.linear.x = 0.0
    velocity_msg.angular.z = 0.0
    slope_goal_center = position.y / position.x
    angle = math.atan(slope_goal_center)
    _, curr_ang = get_odom_data()
    curr_ang = round(curr_ang, 2)
    angle = round(angle, 2)
    # print(math.pi)

    if position.x > 0:
        angle = (angle + math.pi) % (2 * math.pi)

    # print(curr_ang, angle_degree, angle)

    global flag
    while distance_to_goal < 0.05 and abs(angle - curr_ang) > 0.2 and flag != 1:
        if goal_x == 1.0 and goal_y == 2.0:
            break
        if distance_to_goal > 0.1:
            break
        velocity_msg.angular.z = 0.5
        pub.publish(velocity_msg)
        _, curr_ang = get_odom_data()
        curr_ang = round(curr_ang, 2)
        if abs(angle - curr_ang) <= 0.2:
            flag = 1

    # force the robot to stop by setting linear and angular velocities to 0
    velocity_msg.linear.x = 0.0
    velocity_msg.angular.z = 0.0
    pub.publish(velocity_msg)


def sensor_callback(msg):
    """Callback function to deal with messages on the /scan topic
    Perform the obstacle avoidance after receiving the scan values

    """
    global goal
    # For capturing obstacle over a range
    front_range = min(min(msg.ranges[0:10], msg.ranges[350:361]))
    left_range = min(msg.ranges[10:31])
    right_range = min(msg.ranges[330:351])

    front_threshold = 0.6
    left_threshold = 0.4
    right_threshold = 0.4

    global multiplier
    if relative_dir >= 0:
        multiplier = 1
        if first_x > 0:
            multiplier = -1
    else:
        multiplier = -1
        if first_x > 0:
            multiplier = 1

    go_to_goal()
    if front_range > front_threshold and left_range > left_threshold and right_range > right_threshold:
        go_to_goal()
    else:
        if distance_to_goal > 0.3:
            velocity_msg.linear.x = 0.0
            if left_range < left_threshold:
                rospy.logwarn("Left cut")
                velocity_msg.angular.z = -1.5
            elif right_range < right_threshold:
                rospy.logwarn("Right cut")
                velocity_msg.angular.z = 1.5
            else:
                rospy.logwarn("Front cut")
                velocity_msg.angular.z = 1.5 * multiplier
            pub.publish(velocity_msg)
            rate.sleep()
        else:
            rospy.set_param('current_position', goal)
            rospy.loginfo("Goal Reached")
            rospy.signal_shutdown("Goal Reached")
        if front_range > front_threshold and left_range > left_threshold and right_range > right_threshold:
            go_to_goal()


def read_scan():
    """Set up a subscriber for the scan topic

    """
    rospy.Subscriber("scan", LaserScan, sensor_callback, queue_size=1)
    rospy.spin()


# Run the following is this file is called from the package bot_controller
# ros run bot_controller my_bot_controller <arguments>
if __name__ == "__main__":
    if len(sys.argv) != 2:
        sys.exit('Not enough arguments passed to the command line')
    read_scan()
